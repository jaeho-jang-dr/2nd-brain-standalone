// üìä 2nd Brain Îç∞Ïù¥ÌÑ∞ Í¥ÄÎ¶¨ Î∞è Ïù∏Îç±Ïã± ÏãúÏä§ÌÖú

class DataManager {
    constructor(app) {
        this.app = app;
        this.indexedData = new Map();
        this.classifications = {
            byDate: new Map(),
            byPerson: new Map(),
            byClass: new Map(),
            byImportance: new Map(),
            byTags: new Map(),
            byType: new Map()
        };
        
        this.init();
    }

    init() {
        this.buildIndexes();
        this.setupAutoIndexing();
    }

    // üîç Ïù∏Îç±Ïä§ Íµ¨Ï∂ï
    buildIndexes() {
        const memories = this.app.memories || [];
        
        // Í∏∞Ï°¥ Ïù∏Îç±Ïä§ Ï¥àÍ∏∞Ìôî
        Object.values(this.classifications).forEach(map => map.clear());
        
        memories.forEach(memory => {
            this.addToIndexes(memory);
        });
        
        console.log('üìä Îç∞Ïù¥ÌÑ∞ Ïù∏Îç±Ïä§ Íµ¨Ï∂ï ÏôÑÎ£å:', {
            totalMemories: memories.length,
            dateGroups: this.classifications.byDate.size,
            personGroups: this.classifications.byPerson.size,
            classGroups: this.classifications.byClass.size,
            importanceGroups: this.classifications.byImportance.size
        });
    }

    // üìã Î©îÎ™®Î¶¨Î•º Ïù∏Îç±Ïä§Ïóê Ï∂îÍ∞Ä
    addToIndexes(memory) {
        // ÎÇ†ÏßúÎ≥Ñ Ïù∏Îç±Ïã±
        this.indexByDate(memory);
        
        // ÏÇ¨Ïö©ÏûêÎ≥Ñ Ïù∏Îç±Ïã±
        this.indexByPerson(memory);
        
        // Î∂ÑÎ•òÎ≥Ñ Ïù∏Îç±Ïã±
        this.indexByClass(memory);
        
        // Ï§ëÏöîÎèÑÎ≥Ñ Ïù∏Îç±Ïã±
        this.indexByImportance(memory);
        
        // ÌÉúÍ∑∏Î≥Ñ Ïù∏Îç±Ïã±
        this.indexByTags(memory);
        
        // ÌÉÄÏûÖÎ≥Ñ Ïù∏Îç±Ïã±
        this.indexByType(memory);
    }

    // üìÖ ÎÇ†ÏßúÎ≥Ñ Ïù∏Îç±Ïã±
    indexByDate(memory) {
        const date = new Date(memory.timestamp);
        const dateKey = date.toISOString().split('T')[0]; // YYYY-MM-DD
        const monthKey = dateKey.substring(0, 7); // YYYY-MM
        const yearKey = dateKey.substring(0, 4); // YYYY
        
        // ÏùºÎ≥Ñ
        if (!this.classifications.byDate.has(dateKey)) {
            this.classifications.byDate.set(dateKey, []);
        }
        this.classifications.byDate.get(dateKey).push(memory);
        
        // ÏõîÎ≥Ñ
        const monthlyKey = `month_${monthKey}`;
        if (!this.classifications.byDate.has(monthlyKey)) {
            this.classifications.byDate.set(monthlyKey, []);
        }
        this.classifications.byDate.get(monthlyKey).push(memory);
        
        // Ïó∞Î≥Ñ
        const yearlyKey = `year_${yearKey}`;
        if (!this.classifications.byDate.has(yearlyKey)) {
            this.classifications.byDate.set(yearlyKey, []);
        }
        this.classifications.byDate.get(yearlyKey).push(memory);
    }

    // üë§ ÏÇ¨Ïö©ÏûêÎ≥Ñ Ïù∏Îç±Ïã±
    indexByPerson(memory) {
        const person = memory.person || memory.createdBy || 'unknown';
        
        if (!this.classifications.byPerson.has(person)) {
            this.classifications.byPerson.set(person, []);
        }
        this.classifications.byPerson.get(person).push(memory);
    }

    // üè∑Ô∏è Î∂ÑÎ•òÎ≥Ñ Ïù∏Îç±Ïã±
    indexByClass(memory) {
        const memoryClass = this.determineMemoryClass(memory);
        
        if (!this.classifications.byClass.has(memoryClass)) {
            this.classifications.byClass.set(memoryClass, []);
        }
        this.classifications.byClass.get(memoryClass).push(memory);
    }

    // ‚≠ê Ï§ëÏöîÎèÑÎ≥Ñ Ïù∏Îç±Ïã±
    indexByImportance(memory) {
        const importance = memory.importance || 5;
        const importanceLevel = this.getImportanceLevel(importance);
        
        if (!this.classifications.byImportance.has(importanceLevel)) {
            this.classifications.byImportance.set(importanceLevel, []);
        }
        this.classifications.byImportance.get(importanceLevel).push(memory);
    }

    // üè∑Ô∏è ÌÉúÍ∑∏Î≥Ñ Ïù∏Îç±Ïã±
    indexByTags(memory) {
        const tags = memory.tags || [];
        
        tags.forEach(tag => {
            if (!this.classifications.byTags.has(tag)) {
                this.classifications.byTags.set(tag, []);
            }
            this.classifications.byTags.get(tag).push(memory);
        });
    }

    // üìù ÌÉÄÏûÖÎ≥Ñ Ïù∏Îç±Ïã±
    indexByType(memory) {
        const type = memory.type || 'unknown';
        
        if (!this.classifications.byType.has(type)) {
            this.classifications.byType.set(type, []);
        }
        this.classifications.byType.get(type).push(memory);
    }

    // ü§ñ Î©îÎ™®Î¶¨ Î∂ÑÎ•ò Í≤∞Ï†ï
    determineMemoryClass(memory) {
        const content = memory.content.toLowerCase();
        const tags = memory.tags || [];
        
        // ÌÇ§ÏõåÎìú Í∏∞Î∞ò Î∂ÑÎ•ò
        const classificationRules = {
            'work': ['ÌöåÏùò', 'ÏóÖÎ¨¥', 'ÌîÑÎ°úÏ†ùÌä∏', 'Ïùº', 'ÎØ∏ÌåÖ', 'Î≥¥Í≥†ÏÑú', 'Î∞úÌëú'],
            'personal': ['Í∞úÏù∏', 'Í∞ÄÏ°±', 'ÏπúÍµ¨', 'Ï∑®ÎØ∏', 'Ïö¥Îèô', 'Í±¥Í∞ï'],
            'learning': ['Í≥µÎ∂Ä', 'ÌïôÏäµ', 'Ï±Ö', 'Í∞ïÏùò', 'ÏàòÏóÖ', 'ÍµêÏú°', 'Ïó∞Íµ¨'],
            'travel': ['Ïó¨Ìñâ', 'Ìú¥Í∞Ä', 'Í¥ÄÍ¥ë', 'Ìò∏ÌÖî', 'ÎπÑÌñâÍ∏∞', 'Í∏∞Ï∞®'],
            'food': ['ÏùåÏãù', 'ÏöîÎ¶¨', 'ÏãùÎãπ', 'Î†àÏãúÌîº', 'Ïπ¥Ìéò', 'ÎßõÏßë'],
            'shopping': ['ÏáºÌïë', 'Íµ¨Îß§', 'Ïò®ÎùºÏù∏', 'Î∞∞ÏÜ°', 'Ï£ºÎ¨∏', 'Í≤∞Ï†ú'],
            'health': ['Î≥ëÏõê', 'ÏùòÏÇ¨', 'ÏïΩ', 'ÏπòÎ£å', 'Í≤ÄÏÇ¨', 'Í±¥Í∞ï'],
            'finance': ['Îèà', 'Í≤∞Ï†ú', 'ÏùÄÌñâ', 'Ìà¨Ïûê', 'Ï£ºÏãù', 'Î≥¥Ìóò'],
            'entertainment': ['ÏòÅÌôî', 'ÏùåÏïÖ', 'Í≤åÏûÑ', 'Ïä§Ìè¨Ï∏†', 'Í≥µÏó∞', 'ÎìúÎùºÎßà'],
            'ideas': ['ÏïÑÏù¥ÎîîÏñ¥', 'ÏÉùÍ∞Å', 'Í≥ÑÌöç', 'Î™©Ìëú', 'Íøà', 'ÏòÅÍ∞ê']
        };
        
        // ÌÉúÍ∑∏ Ïö∞ÏÑ† Í≤ÄÏÇ¨
        for (const tag of tags) {
            for (const [className, keywords] of Object.entries(classificationRules)) {
                if (keywords.includes(tag)) {
                    return className;
                }
            }
        }
        
        // ÎÇ¥Ïö© Í∏∞Î∞ò Í≤ÄÏÇ¨
        for (const [className, keywords] of Object.entries(classificationRules)) {
            if (keywords.some(keyword => content.includes(keyword))) {
                return className;
            }
        }
        
        // ÌÉÄÏûÖ Í∏∞Î∞ò Í∏∞Î≥∏ Î∂ÑÎ•ò
        const typeBasedClass = {
            'photo': 'media',
            'video': 'media',
            'voice': 'notes',
            'text': 'notes',
            'location': 'places',
            'document': 'documents'
        };
        
        return typeBasedClass[memory.type] || 'general';
    }

    // ‚≠ê Ï§ëÏöîÎèÑ Î†àÎ≤® Í≤∞Ï†ï
    getImportanceLevel(importance) {
        if (importance >= 9) return 'critical';
        if (importance >= 7) return 'high';
        if (importance >= 5) return 'medium';
        if (importance >= 3) return 'low';
        return 'minimal';
    }

    // üîÑ ÏûêÎèô Ïù∏Îç±Ïã± ÏÑ§Ï†ï
    setupAutoIndexing() {
        // Î©îÎ™®Î¶¨ Ï∂îÍ∞Ä Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
        document.addEventListener('memoryAdded', (e) => {
            this.addToIndexes(e.detail.memory);
        });
        
        // Î©îÎ™®Î¶¨ ÏÇ≠Ï†ú Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
        document.addEventListener('memoryDeleted', (e) => {
            this.removeFromIndexes(e.detail.memoryId);
        });
        
        // Î©îÎ™®Î¶¨ ÏóÖÎç∞Ïù¥Ìä∏ Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
        document.addEventListener('memoryUpdated', (e) => {
            this.updateInIndexes(e.detail.memory);
        });
    }

    // üóëÔ∏è Ïù∏Îç±Ïä§ÏóêÏÑú Î©îÎ™®Î¶¨ Ï†úÍ±∞
    removeFromIndexes(memoryId) {
        Object.values(this.classifications).forEach(map => {
            map.forEach((memories, key) => {
                const filteredMemories = memories.filter(m => m.id !== memoryId);
                if (filteredMemories.length === 0) {
                    map.delete(key);
                } else {
                    map.set(key, filteredMemories);
                }
            });
        });
    }

    // üîÑ Ïù∏Îç±Ïä§ÏóêÏÑú Î©îÎ™®Î¶¨ ÏóÖÎç∞Ïù¥Ìä∏
    updateInIndexes(memory) {
        this.removeFromIndexes(memory.id);
        this.addToIndexes(memory);
    }

    // üîç Í≥†Í∏â Í≤ÄÏÉâ Î©îÏÑúÎìú
    searchByClassification(type, value, options = {}) {
        const classification = this.classifications[`by${type.charAt(0).toUpperCase() + type.slice(1)}`];
        
        if (!classification || !classification.has(value)) {
            return [];
        }
        
        let results = [...classification.get(value)];
        
        // Ï∂îÍ∞Ä ÌïÑÌÑ∞ÎßÅ
        if (options.dateRange) {
            results = this.filterByDateRange(results, options.dateRange);
        }
        
        if (options.importance) {
            results = results.filter(m => (m.importance || 5) >= options.importance);
        }
        
        if (options.type) {
            results = results.filter(m => m.type === options.type);
        }
        
        if (options.tags) {
            results = results.filter(m => 
                options.tags.some(tag => (m.tags || []).includes(tag))
            );
        }
        
        // Ï†ïÎ†¨
        const sortBy = options.sortBy || 'date';
        results = this.sortResults(results, sortBy);
        
        // Ï†úÌïú
        if (options.limit) {
            results = results.slice(0, options.limit);
        }
        
        return results;
    }

    // üìä Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù Î©îÏÑúÎìú
    getDataStatistics() {
        const memories = this.app.memories || [];
        
        return {
            total: memories.length,
            byType: this.getCountByClassification('Type'),
            byClass: this.getCountByClassification('Class'),
            byImportance: this.getCountByClassification('Importance'),
            byDate: this.getDateStatistics(),
            recentActivity: this.getRecentActivity(),
            topTags: this.getTopTags(),
            storageInfo: this.getStorageInfo()
        };
    }

    getCountByClassification(type) {
        const classification = this.classifications[`by${type}`];
        const counts = {};
        
        classification.forEach((memories, key) => {
            counts[key] = memories.length;
        });
        
        return counts;
    }

    getDateStatistics() {
        const today = new Date();
        const thisWeek = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
        const thisMonth = new Date(today.getFullYear(), today.getMonth(), 1);
        
        return {
            today: this.countMemoriesSince(today.toISOString().split('T')[0]),
            thisWeek: this.countMemoriesSince(thisWeek.toISOString().split('T')[0]),
            thisMonth: this.countMemoriesSince(thisMonth.toISOString().split('T')[0])
        };
    }

    countMemoriesSince(dateString) {
        const memories = this.app.memories || [];
        return memories.filter(memory => 
            memory.timestamp >= dateString
        ).length;
    }

    getRecentActivity() {
        const memories = this.app.memories || [];
        const last24Hours = new Date(Date.now() - 24 * 60 * 60 * 1000);
        
        return memories
            .filter(memory => new Date(memory.timestamp) > last24Hours)
            .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
            .slice(0, 10);
    }

    getTopTags(limit = 10) {
        const tagCounts = new Map();
        
        this.classifications.byTags.forEach((memories, tag) => {
            tagCounts.set(tag, memories.length);
        });
        
        return Array.from(tagCounts.entries())
            .sort(([,a], [,b]) => b - a)
            .slice(0, limit)
            .map(([tag, count]) => ({ tag, count }));
    }

    getStorageInfo() {
        const memories = this.app.memories || [];
        let totalSize = 0;
        
        // LocalStorage ÌÅ¨Í∏∞ Í≥ÑÏÇ∞
        for (let key in localStorage) {
            if (key.startsWith('2nd_brain_')) {
                totalSize += localStorage[key].length;
            }
        }
        
        return {
            memoriesCount: memories.length,
            storageUsed: Math.round(totalSize / 1024), // KB
            averageMemorySize: memories.length > 0 ? Math.round(totalSize / memories.length) : 0
        };
    }

    // üîÑ Ï†ïÎ†¨ Î©îÏÑúÎìú
    sortResults(results, sortBy) {
        switch (sortBy) {
            case 'date':
                return results.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            case 'importance':
                return results.sort((a, b) => (b.importance || 5) - (a.importance || 5));
            
            case 'type':
                return results.sort((a, b) => a.type.localeCompare(b.type));
            
            case 'person':
                return results.sort((a, b) => {
                    const personA = a.person || a.createdBy || 'unknown';
                    const personB = b.person || b.createdBy || 'unknown';
                    return personA.localeCompare(personB);
                });
            
            case 'random':
                return this.shuffleArray([...results]);
            
            default:
                return results;
        }
    }

    shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    // üìÖ ÎÇ†Ïßú Î≤îÏúÑ ÌïÑÌÑ∞ÎßÅ
    filterByDateRange(memories, dateRange) {
        const { start, end } = dateRange;
        return memories.filter(memory => {
            const memoryDate = new Date(memory.timestamp);
            return (!start || memoryDate >= new Date(start)) &&
                   (!end || memoryDate <= new Date(end));
        });
    }

    // üîç Ïä§ÎßàÌä∏ Í≤ÄÏÉâ
    smartSearch(query, options = {}) {
        const memories = this.app.memories || [];
        let results = [];
        
        // ÌÇ§ÏõåÎìú Î∂ÑÏÑù
        const keywords = query.toLowerCase().split(' ');
        
        // ÌäπÎ≥Ñ Í≤ÄÏÉâ Ìå®ÌÑ¥ Í∞êÏßÄ
        const patterns = {
            datePattern: /(\d{4})-(\d{2})-(\d{2})|(\d{2})\/(\d{2})\/(\d{4})|Ïò§Îäò|Ïñ¥Ï†ú|Ïù¥Î≤àÏ£º|ÏßÄÎÇúÏ£º|Ïù¥Î≤àÎã¨|ÏßÄÎÇúÎã¨/,
            importancePattern: /Ï§ëÏöî|urgent|high|low|ÎÜíÏùÄ|ÎÇÆÏùÄ/,
            typePattern: /ÏÇ¨ÏßÑ|photo|ÏùåÏÑ±|voice|ÌÖçÏä§Ìä∏|text|ÏòÅÏÉÅ|video|ÏúÑÏπò|location/,
            personPattern: /@(\w+)|ÏÇ¨Ïö©Ïûê|user/
        };
        
        // Ìå®ÌÑ¥Î≥Ñ Í≤ÄÏÉâ
        if (patterns.datePattern.test(query)) {
            results = this.searchByDatePattern(query);
        } else if (patterns.importancePattern.test(query)) {
            results = this.searchByImportancePattern(query);
        } else if (patterns.typePattern.test(query)) {
            results = this.searchByTypePattern(query);
        } else {
            // ÏùºÎ∞ò ÌÖçÏä§Ìä∏ Í≤ÄÏÉâ
            results = this.performTextSearch(query, memories);
        }
        
        // Ï∂îÍ∞Ä ÌïÑÌÑ∞ Ï†ÅÏö©
        if (options.filters) {
            results = this.applyFilters(results, options.filters);
        }
        
        // Ï†ïÎ†¨
        results = this.sortResults(results, options.sortBy || 'date');
        
        return results;
    }

    performTextSearch(query, memories) {
        const keywords = query.toLowerCase().split(' ');
        
        return memories.filter(memory => {
            const searchableText = [
                memory.content,
                ...(memory.tags || []),
                memory.type,
                memory.person || memory.createdBy || ''
            ].join(' ').toLowerCase();
            
            return keywords.some(keyword => searchableText.includes(keyword));
        });
    }

    searchByDatePattern(query) {
        const lowerQuery = query.toLowerCase();
        let dateKey = '';
        
        if (lowerQuery.includes('Ïò§Îäò')) {
            dateKey = new Date().toISOString().split('T')[0];
        } else if (lowerQuery.includes('Ïñ¥Ï†ú')) {
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            dateKey = yesterday.toISOString().split('T')[0];
        } else if (lowerQuery.includes('Ïù¥Î≤àÏ£º')) {
            return this.getThisWeekMemories();
        } else if (lowerQuery.includes('ÏßÄÎÇúÏ£º')) {
            return this.getLastWeekMemories();
        }
        
        return this.classifications.byDate.get(dateKey) || [];
    }

    getThisWeekMemories() {
        const now = new Date();
        const startOfWeek = new Date(now.setDate(now.getDate() - now.getDay()));
        const endOfWeek = new Date(now.setDate(startOfWeek.getDate() + 6));
        
        return this.filterByDateRange(this.app.memories || [], {
            start: startOfWeek.toISOString().split('T')[0],
            end: endOfWeek.toISOString().split('T')[0]
        });
    }

    // üìä Ïù∏Îç±Ïä§ ÏÉÅÌÉú Î¶¨Ìè¨Ìä∏
    getIndexReport() {
        return {
            totalMemories: this.app.memories?.length || 0,
            indexes: {
                byDate: this.classifications.byDate.size,
                byPerson: this.classifications.byPerson.size,
                byClass: this.classifications.byClass.size,
                byImportance: this.classifications.byImportance.size,
                byTags: this.classifications.byTags.size,
                byType: this.classifications.byType.size
            },
            topClassifications: {
                mostActiveDate: this.getMostActive('byDate'),
                mostActivePerson: this.getMostActive('byPerson'),
                mostActiveClass: this.getMostActive('byClass'),
                mostUsedTag: this.getMostActive('byTags')
            }
        };
    }

    getMostActive(classificationType) {
        const classification = this.classifications[classificationType];
        let maxCount = 0;
        let mostActive = null;
        
        classification.forEach((memories, key) => {
            if (memories.length > maxCount) {
                maxCount = memories.length;
                mostActive = key;
            }
        });
        
        return { key: mostActive, count: maxCount };
    }

    // üßπ Ïù∏Îç±Ïä§ ÏµúÏ†ÅÌôî
    optimizeIndexes() {
        // Îπà Ïù∏Îç±Ïä§ Ï†ïÎ¶¨
        Object.values(this.classifications).forEach(map => {
            map.forEach((memories, key) => {
                if (memories.length === 0) {
                    map.delete(key);
                }
            });
        });
        
        // Ïù∏Îç±Ïä§ Ïû¨Íµ¨Ï∂ï
        this.buildIndexes();
        
        console.log('üßπ Îç∞Ïù¥ÌÑ∞ Ïù∏Îç±Ïä§ ÏµúÏ†ÅÌôî ÏôÑÎ£å');
        return this.getIndexReport();
    }
}

// Ï†ÑÏó≠ÏóêÏÑú ÏÇ¨Ïö©Ìï† Ïàò ÏûàÎèÑÎ°ù ÎÇ¥Î≥¥ÎÇ¥Í∏∞
window.DataManager = DataManager;